plugins {
    id 'com.github.ben-manes.versions' version '0.13.0'
    id 'groovy'
    id 'war'
    id 'idea'
}

ext {
    // Case insensitive list of version qualifers to blacklist when checking for updates.
    // hamcrest has a rogue 'atlassian-1' release...?
    // javax.servlet uses 'b' instead of 'beta'.
    // jetty uses 'M' for release candidates.
    dependencyQualiferBlacklist = ['alpha', 'beta', 'rc', 'b', 'm', 'atlassian']

    jerseyVersion = '2.23.2'
}

repositories {
    jcenter()
    mavenCentral()
}

configurations {
    jetty
}

dependencies {
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'

    compile 'org.codehaus.groovy:groovy-all:2.4.7'
    compile 'javax.ws.rs:javax.ws.rs-api:2.0.1'
    compile "org.glassfish.jersey.containers:jersey-container-servlet-core:${jerseyVersion}"
    compile "org.glassfish.jersey.media:jersey-media-json-jackson:${jerseyVersion}"

    runtime 'ch.qos.logback:logback-classic:1.1.7'

    jetty 'org.eclipse.jetty:jetty-runner:9.3.11.v20160721'

    testCompile 'org.hamcrest:hamcrest-library:1.3'
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    // These two are optional dependencies for spock that are needed for mocking classes (instead of interfaces).
    testCompile 'cglib:cglib-nodep:3.2.4'
    testCompile 'org.objenesis:objenesis:2.4'
}

sourceCompatibility = 1.8

compileJava {
    options.deprecation = true
    options.compilerArgs = ['-Xlint:unchecked']
}

test {
    testLogging {
      events 'passed', 'skipped', 'failed'
      exceptionFormat 'full'
    }
}

task run(dependsOn: assemble, type: JavaExec) {
    description = 'Run the war in a local Jetty server.'
    classpath configurations.jetty
    main = 'org.eclipse.jetty.runner.Runner'
    args = ['--path', '/', war.archivePath]
}

task wrapper(type: Wrapper) {
    description = 'Bootstrap the gradlew scripts.'
    gradleVersion = '3.0'
}

// Ignore release candidates when searching for dependency updates.
dependencyUpdates.resolutionStrategy {
    componentSelection { rules ->
        rules.all { selection ->
            def matcher = selection.candidate.version =~ /(?i)[.-](${dependencyQualiferBlacklist.join('|')})/
            if (matcher) {
                def reason = "Blacklisting [${selection.candidate}] due to qualifier [${matcher.group(1)}]"
                selection.reject(reason)
            }
        }
    }
}
